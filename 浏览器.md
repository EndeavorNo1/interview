1.并行，同时处理多个任务。
2.线程vs进程 
进程：一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。 
进程和线程之间的关系：
1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。  
2. 线程之间共享进程中的数据。    
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。
### web浏览器页面性能
------------- 
1. 在衡量Web页面性能的时候有一个重要的指标叫“FP（First Paint）”，是指从页面加载到首次开始绘制的时长。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的PV、更高的参与度，以及更高的转化率。那什么影响FP指标呢？其中一个重要的因素是网络加载速度    
2. 计算机的地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。    
3. 网络层，附加ip头+解析ip头   
4. “用户数据包协议（User Datagram Protocol）”，简称UDP。确定数据包交给哪个程序   
5. IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。   
6. 传输层，会在数据包前面附加上UDP头，组成新的UDP数据包，再将新的UDP数据包交给网络层；    
7. UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等    
8. 对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用UDP来传输会存在两个问题：   
 - 8-1数据包在传输过程中容易丢失；  
 - 8-2大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDP协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件
9. TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP有下面两个特点:
  - 对于数据包丢失的情况，TCP提供重传机制；
  - TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
10. 一个完整的TCP连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段 
11. TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。 
12. HTTP协议，正是建立在TCP连接基础之上的。HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如HTML文件、CSS文件、JavaScript文件、图片、视频等。
13. 可以通过工具软件curl来查看返回请求数据 curl -i  https://time.geekbang.org/
14. 首先服务器会返回响应行，包括协议版本和状态码。
15. 响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的Cookie等信息。
16. 发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了HTML的实际内容。
17. Connection:Keep-Alive 那么TCP连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求。保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个Web页面中内嵌的图片就都来自同一个Web站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的TCP连接。
18. curl -I geekbang.org -I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据
19. 通过响应头中的Cache-Control字段来设置是否缓存该资源，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过Cache-Control中的Max-age参数来设置的Cache-Control:Max-age=2000
20. 在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP请求头中带上If-None-Match:"4f80f-13c-3a1xb12a" 服务器收到请求头后，会根据If-None-Match的值来判断请求的资源是否有更新。如果没有更新，就返回304状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”如果资源有更新，服务器就直接返回最新资源给浏览器。
21. Set-Cookie: UID=3431uad;Cookie: UID=3431uad;
22. 浏览器中的HTTP请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备IP和端口、等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接。

### 在浏览器里，从输入URL到页面展示，这中间发生了什么？

```
websocket
WebSocket 是一种基于 TCP 协议的双向通信协议，可以在浏览器和服务器之间建立实时、持久性的连接，使得客户端和服务器能够进行实时数据交互。

下面是一个简单的使用 WebSocket 的示例：

首先创建一个 WebSocket 对象，传入服务器的地址作为构造函数参数：
var socket = new WebSocket('ws://example.com/socketserver');
监听 WebSocket 的打开事件，并在该事件发生后发送一些数据给服务器：
socket.onopen = function() {
  socket.send('Hello, server!');
};
监听 WebSocket 的消息事件，当有消息从服务器传来时，处理这些消息：
socket.onmessage = function(event) {
  console.log('Received message: ' + event.data);
};
监听 WebSocket 的关闭事件，当连接被关闭时执行一些操作：
socket.onclose = function(event) {
  console.log('Closed connection.');
};
最后，在必要的时候关闭 WebSocket 连接：
socket.close();
需要注意的是，WebSocket 并不是所有浏览器都支持，因此在使用时需要进行兼容性考虑。同时，由于 WebSocket 是一种全新的协议，因此服务器端也需要特定的支持才能与客户端进行通信。
```
------ 

[参考/学习链接](https://blog.poetries.top/browser-working-principle/guide/part1/lesson03.html#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B)
